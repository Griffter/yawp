{"name":"YAWP!","tagline":"Yet Another Web API for Google App Engine","body":"# YAWP!\r\n\r\nYet Another Web Persistence API\r\n\r\n[![Build Status](https://api.shippable.com/projects/540e77983479c5ea8f9e8eee/badge?branchName=master)](https://app.shippable.com/projects/540e77983479c5ea8f9e8eee/builds/latest)\r\n\r\n## Introduction\r\n\r\nYAWP! is a Java framework built on top of Google App Engine, whose main purpose is to provide a simple and meaningful API to support REST based applications.  \r\nYou create your POJOs and YAWP! creates a full REST url schema to insert, delete, update, list, etc. your objects automatically.  \r\nThen you can change default the behavior via Actions, Transformers and Hooks. Never write a controller in your life again!\r\n\r\n## Features\r\n\r\n * Amazingly simple\r\n * Nice querying syntax encapsulating GAE's Query classes.\r\n * Nested resources using GAE Parent/Child functionality\r\n * Hook, Action and Transformers API\r\n\r\n## Examples\r\n\r\nIn a very simple example, we can create the class User, with just a few fields:\r\n\r\n    public class User {\r\n\r\n        private String name;\r\n        private int age;\r\n        private String company;\r\n    }\r\n\r\nNow, in order to use YAWP!, just annotate this class with @Endpoint annotation, and add an IdRef&lt;User&gt; field.\r\n\r\n    @Endpoint(path = \"/users\")\r\n    public class User {\r\n\r\n        @Id\r\n        private IdRef<User> id;\r\n\r\n        /* ... */\r\n\r\n    }\r\n\r\nDone. Now User is mapped to \"/users\", and all these urls will be generated:\r\n\r\n * GET /users -> list all users\r\n * GET /users/:id -> get a user by id\r\n * POST /users -> create new user with random id\r\n * POST /users/:id -> create a new user with given id\r\n * PUT /users/:id -> update user with given id\r\n * DELETE /users/:id -> deletes user with given id\r\n\r\n###IdRef\r\nThe IdRef<T> class is a simple wrapper around a long. In YAWP!, every id is a long, and IdRef encapsulates that to make it type safe - that way, you won't be able to assing IdRef&lt;User&gt; to IdRef&lt;Product&gt;, for example.  \r\nIt also holds information about the parent id, when such feature is used. Therefore, every id in the system (being primary or foreign key) must be of this type.\r\n\r\n### Action\r\nAn action is a custom action that can be called over an element or a collection. The default actions already include every REST action, but some entities have business actions associated with then; for example, activate a user, or return the current logged user.\r\n\r\n    public class UserActions extends Action<User> {\r\n\r\n        @PUT(\"activate\")\r\n        public User activate(IdRef<User> user) {\r\n            return r.save(user.fetch().activate());\r\n        }\r\n\r\n        @GET(\"me\", overCollection = true)\r\n        public User me() {\r\n            return Session.getLoggedUser();\r\n        }\r\n    }\r\n\r\nNow, the following routes will be created and mapped to your methods:\r\n\r\n  * GET /users/me -> call the action me()\r\n  * PUT /users/id/activate -> activate the user on id\r\n\r\nNote that, since all ids are long, actions name must start with a letter.\r\n\r\n### Transformer\r\nA Transformer can change an object before it is sent on a request. For example, imagine that in some scenarios we don't want to return the User's age in some requests and, in others, we want to calculate he's birth year.\r\n\r\n    public class UserTransformer extends Transformer<User> {\r\n\r\n        public Map<String, String> simple(User user) {\r\n            Map<String, String> result = new HashMap<>();\r\n            result.put(\"name\", user.getName());\r\n            result.put(\"company\", user.getCompany());\r\n            return result;\r\n        }\r\n\r\n        public static class UserView {\r\n            private String name;\r\n            private String company;\r\n            private int birthYear;\r\n\r\n            public UserView(User user) {\r\n                this.name = user.getName();\r\n                this.company = user.getCompany();\r\n                this.birthYear = Calendar.getInstance().get(Calendar.YEAR) - user.getAge();\r\n            }\r\n        }\r\n\r\n        public UserView withYear(User user) {\r\n            return new UserView(user);\r\n        }\r\n    }\r\n\r\nTo use the transformer, just add a query param to the request:\r\n\r\n * GET /users/id?t=simple -> Returns the user with id applying the transformer simple()\r\n * GET /users?t=withYear -> Returns the list of all users applying the transformer withYear()\r\n\r\n### Hooks\r\nHooks are codes that are executed before or after a particular action in the system. They can be used to set pre-calculated information in the models to be saved in the database, or to deny access to some users on certain actions, for example. Take a look at this Hook:\r\n\r\n    public class UserHook extends Hook<User> {\r\n\r\n        @Override\r\n\tpublic void beforeQuery(DatastoreQuery<User> q) {\r\n            q.where(\"company\", \"=\", Session.getLoggedUser().getCompany());\r\n        }\r\n\r\n        @Override\r\n        public void beforeSave(User user) {\r\n            if (user.getAge() < 18) {\r\n                throw new HttpException(422, \"You must be 18 or more to sign up.\");\r\n            }\r\n        }\r\n    }\r\n\r\nThis example uses two hook methods. For now, there are only 3 of them:\r\n\r\n * beforeQuery : called before any query made via a URL. It can be used to add security or default validations;\r\n * beforeSave : called before an object is saved. It can be used to pre-calculate or cache some values in the entity, as well as make validations before saving;\r\n * afterSave : called after an object is saved. It can be used to trigger actions or log events.\r\n\r\n### Querying API\r\nThe beforeQuery method recieves a DatastoreQuery<T>. This class is part of the core Query API that YAWP! provides, and it allows for very easy access to the GAE database.  \r\nIt can be used within any Repository Feature (i.e., Action, Transformer or Hook). In fact, any of those has a private variable r that represents the Repository. With it, you can the query method to get access to que Query API. See some cool examples:\r\n\r\n * r.query(User.class).where(\"name\", \"=\", \"Mark\").and(\"age\", \">=\", 21).list();\r\n * r.query(User.class).where(or(and(c(\"company\", \"=\", \"github.com\"), c(\"age\", \">=\", 21)), and(c(\"company\", \"=\", \"YAWP!\"), c(\"age\", \">=\", 18)))).ids();\r\n   The methods c, and and or must be imported static or fully qualified on call for this to work.\r\n * r.query(User.class).where(\"name\", \"=\", \"John\").and(\"company\", \"=\", \"github.com\").only();\r\n\r\n## Frontend\r\nA frontend api for Javascript is coming soon. Keep tunned for updates!\r\n\r\n## Misc\r\n * http://stackoverflow.com/questions/7160006/m2e-and-having-maven-generated-source-folders-as-eclipse-source-folders\r\n","google":"UA-54832827-1","note":"Don't delete this file! It's used internally to help with page regeneration."}